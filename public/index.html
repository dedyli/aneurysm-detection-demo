
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEREBRO: AI Stroke Triage System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background-color: #0f0f0f;
        }
        .mono { font-family: 'IBM Plex Mono', monospace; }
        .viewer-panel { background: #1a1a1a; border: 1px solid #2d2d2d; }
        .side-panel { background: #1a1a1a; border: 1px solid #2d2d2d; }
        .tool-btn {
            background: #2d2d2d;
            border: 1px solid #3d3d3d;
            color: #b0b0b0;
            transition: all 0.15s;
        }
        .tool-btn:hover { background: #3d3d3d; color: #fff; }
        .tool-btn.active { background: #0ea5e9; color: #fff; border-color: #0ea5e9; }
        .tab-btn {
            background: transparent;
            border-bottom: 2px solid transparent;
            color: #808080;
            padding: 8px 16px;
            transition: all 0.15s;
        }
        .tab-btn:hover { color: #b0b0b0; }
        .tab-btn.active { color: #0ea5e9; border-bottom-color: #0ea5e9; }
        .metadata-overlay {
            position: absolute;
            font-size: 11px;
            color: #e5e5e5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
        }
        .loader {
            border: 3px solid #2d2d2d;
            border-radius: 50%;
            border-top: 3px solid #0ea5e9;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #image-canvas {
            cursor: crosshair;
            image-rendering: crisp-edges;
        }
        .measurement-line {
            stroke: #0ea5e9;
            stroke-width: 2;
            fill: none;
        }
        .measurement-point {
            fill: #0ea5e9;
            stroke: #fff;
            stroke-width: 1;
        }
        .measurement-text {
            fill: #0ea5e9;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            font-weight: 500;
        }
        .heatmap-overlay {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,0,0,0.5) 0%, rgba(255,100,0,0.3) 40%, rgba(255,200,0,0.1) 70%, transparent 100%);
            pointer-events: none;
            border: 2px solid rgba(255,0,0,0.6);
        }
        input[type="text"], textarea {
            background: #2d2d2d;
            border: 1px solid #3d3d3d;
            color: #e5e5e5;
        }
        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #0ea5e9;
        }
        .status-bar {
            background: #1a1a1a;
            border-top: 1px solid #2d2d2d;
            font-size: 11px;
            color: #808080;
        }
        .urgency-critical { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
        .urgency-high { background: #7c2d12; border-color: #9a3412; color: #fed7aa; }
        .urgency-moderate { background: #713f12; border-color: #854d0e; color: #fde68a; }
        .urgency-low { background: #14532d; border-color: #166534; color: #bbf7d0; }
    </style>
</head>
<body class="bg-black text-gray-200">

    <!-- Top Header -->
    <header class="bg-[#1a1a1a] border-b border-[#2d2d2d] h-12 flex items-center px-4">
        <div class="flex items-center space-x-3">
            <svg class="h-7 w-7 text-[#0ea5e9]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="9" />
                <path d="M9 12h6M9 12l-1.5-1.5M9 12l-1.5 1.5M15 12l1.5-1.5M15 12l1.5 1.5" />
            </svg>
            <span class="text-sm font-semibold tracking-wide text-gray-300">CEREBRO</span>
            <span class="text-xs text-gray-500">|</span>
            <span class="text-xs text-gray-500">Stroke Triage AI - Tsinghua IEDE Group 28</span>
        </div>
        <div class="ml-auto flex items-center space-x-3 text-xs">
            <button id="save-btn" class="tool-btn px-3 py-1 rounded text-xs">üíæ Save</button>
            <button id="export-btn" class="tool-btn px-3 py-1 rounded text-xs">üìÑ Export PDF</button>
            <button id="reset-header-btn" class="tool-btn px-3 py-1 rounded text-xs">üîÑ New Case</button>
        </div>
    </header>

    <!-- Main Layout -->
    <div class="flex h-[calc(100vh-3rem-28px)]">
        
        <!-- Left Toolbar -->
        <div class="w-16 bg-[#1a1a1a] border-r border-[#2d2d2d] flex flex-col items-center py-3 space-y-2">
            <button id="tool-upload" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Upload Image">üìÅ</button>
            <button id="tool-pan" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Pan">‚úã</button>
            <button id="tool-zoom" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Zoom">üîç</button>
            <button id="tool-measure" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Measure Distance">üìè</button>
            <button id="tool-annotate" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Annotations">‚úèÔ∏è</button>
            <div class="flex-grow"></div>
            <button id="tool-clear" class="tool-btn w-12 h-12 rounded flex items-center justify-center text-lg" title="Clear Measurements">üóëÔ∏è</button>
        </div>

        <!-- Center: Image Viewer -->
        <div class="flex-grow viewer-panel flex flex-col">
            <!-- Patient Info Bar -->
            <div class="h-10 bg-[#0f0f0f] border-b border-[#2d2d2d] flex items-center px-4 text-xs mono space-x-6">
                <div><span class="text-gray-500">Patient:</span> <span id="patient-name" class="text-gray-300">Anonymous</span></div>
                <div><span class="text-gray-500">ID:</span> <span id="patient-id" class="text-gray-300">-</span></div>
                <div><span class="text-gray-500">Age:</span> <span id="patient-age" class="text-gray-300">-</span></div>
                <div><span class="text-gray-500">Sex:</span> <span id="patient-sex" class="text-gray-300">-</span></div>
                <div class="ml-auto"><span class="text-gray-500">Study:</span> <span id="study-date" class="text-gray-300">-</span></div>
            </div>

            <!-- Image Container -->
            <div id="viewer-container" class="flex-grow relative bg-black overflow-hidden">
                <!-- Upload Placeholder -->
                <div id="upload-placeholder" class="absolute inset-0 flex flex-col items-center justify-center text-gray-600">
                    <svg class="h-16 w-16 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <p class="text-sm">Click üìÅ Upload or drag image here</p>
                    <p class="text-xs text-gray-700 mt-1">Supported: JPEG, PNG, WEBP</p>
                </div>

                <!-- Canvas for Image + Measurements -->
                <canvas id="image-canvas" class="absolute hidden" style="top: 50%; left: 50%; transform: translate(-50%, -50%);"></canvas>

                <!-- Metadata Overlays -->
                <div class="metadata-overlay top-2 left-2 mono">
                    <div id="meta-institution" class="text-[10px] text-gray-400">CEREBRO Triage System</div>
                    <div id="meta-patient-overlay" class="mt-1 text-gray-300">-</div>
                    <div id="meta-scan-params" class="mt-1 text-gray-400 text-[10px]">CT Brain | Axial</div>
                </div>
                <div class="metadata-overlay top-2 right-2 mono text-right">
                    <div id="meta-date-overlay" class="text-gray-300">-</div>
                    <div id="meta-modality" class="mt-1 text-gray-400 text-[10px]">CT</div>
                    <div id="meta-slice" class="mt-1 text-gray-400 text-[10px]">Slice: 1/1</div>
                </div>
                <div class="metadata-overlay bottom-2 left-2 mono">
                    <div id="meta-window" class="text-gray-400 text-[10px]">W/L: 80/40</div>
                    <div id="meta-zoom" class="mt-1 text-gray-400 text-[10px]">Zoom: 100%</div>
                </div>

                <!-- Heatmap Overlay -->
                <div id="heatmap-overlay" class="heatmap-overlay hidden"></div>

                <!-- Hidden File Input -->
                <input id="file-input" type="file" accept="image/*" class="hidden">
            </div>
        </div>

        <!-- Right Panel -->
        <div class="w-96 side-panel flex flex-col">
            <!-- Tabs -->
            <div class="flex border-b border-[#2d2d2d] text-xs">
                <button class="tab-btn active" data-tab="patient">Patient</button>
                <button class="tab-btn" data-tab="analysis">Analysis</button>
                <button class="tab-btn" data-tab="measurements">Measurements</button>
                <button class="tab-btn" data-tab="report">Report</button>
                <button class="tab-btn" data-tab="3d">3D View</button>
            </div>

            <!-- Tab Content -->
            <div class="flex-grow overflow-y-auto p-4">
                
                <!-- Patient Tab -->
                <div id="tab-patient" class="tab-content">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-3">Patient Demographics</h3>
                    <div class="space-y-3 text-sm">
                        <div>
                            <label class="text-xs text-gray-500 block mb-1">Patient Name</label>
                            <input id="input-name" type="text" class="w-full px-2 py-1 text-sm rounded" placeholder="Anonymous">
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs text-gray-500 block mb-1">Age</label>
                                <input id="input-age" type="text" class="w-full px-2 py-1 text-sm rounded" placeholder="65">
                            </div>
                            <div>
                                <label class="text-xs text-gray-500 block mb-1">Sex</label>
                                <input id="input-sex" type="text" class="w-full px-2 py-1 text-sm rounded" placeholder="M/F">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs text-gray-500 block mb-1">Patient ID</label>
                            <input id="input-id" type="text" class="w-full px-2 py-1 text-sm rounded" placeholder="AUTO-" disabled>
                        </div>
                    </div>

                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-3 mt-6">Clinical History</h3>
                    <div>
                        <label class="text-xs text-gray-500 block mb-1">Symptoms & History</label>
                        <textarea id="input-symptoms" rows="10" class="w-full px-2 py-1 text-sm rounded resize-none" placeholder="e.g., 65-year-old male presenting with sudden onset left-sided weakness and slurred speech. Last known normal: 2 hours ago. History: Hypertension, atrial fibrillation..."></textarea>
                    </div>

                    <button id="analyze-btn" class="w-full mt-4 bg-[#0ea5e9] hover:bg-[#0284c7] text-white py-2 rounded text-sm font-medium transition-colors flex items-center justify-center">
                        <span id="analyze-text">Run AI Analysis</span>
                        <div id="analyze-loader" class="loader hidden ml-2"></div>
                    </button>
                </div>

                <!-- Analysis Tab -->
                <div id="tab-analysis" class="tab-content hidden">
                    <div id="analysis-placeholder" class="text-center py-16 text-gray-600">
                        <svg class="mx-auto h-12 w-12 mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        <p class="text-sm">No analysis yet</p>
                        <p class="text-xs mt-1">Upload image and run analysis</p>
                    </div>

                    <div id="analysis-result" class="hidden space-y-4">
                        <!-- Urgency Banner -->
                        <div id="urgency-banner" class="p-3 rounded border flex items-center space-x-3">
                            <div id="urgency-icon" class="text-2xl"></div>
                            <div>
                                <div id="urgency-diagnosis" class="font-semibold text-sm"></div>
                                <div id="urgency-level" class="text-xs opacity-90"></div>
                            </div>
                        </div>

                        <!-- Confidence -->
                        <div>
                            <div class="flex justify-between text-xs text-gray-400 mb-1">
                                <span>AI Confidence</span>
                                <span id="confidence-value" class="mono">-</span>
                            </div>
                            <div class="w-full bg-[#2d2d2d] rounded-full h-2">
                                <div id="confidence-bar" class="bg-[#0ea5e9] h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>

                        <!-- AI Summary -->
                        <div>
                            <h4 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-2">Findings</h4>
                            <div id="ai-summary" class="text-xs leading-relaxed text-gray-300 bg-[#0f0f0f] p-3 rounded border border-[#2d2d2d] whitespace-pre-wrap"></div>
                        </div>

                        <!-- Recommendations -->
                        <div>
                            <h4 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-2">Recommendations</h4>
                            <ul id="recommendations-list" class="text-xs space-y-1 text-gray-300">
                                <li>‚Ä¢ Immediate CT angiography</li>
                                <li>‚Ä¢ Neurology consultation</li>
                                <li>‚Ä¢ Monitor vitals q15min</li>
                            </ul>
                        </div>
                    </div>

                    <div id="analysis-error" class="hidden p-3 bg-red-900/30 border border-red-800 rounded text-red-300 text-xs"></div>
                </div>

                <!-- Measurements Tab -->
                <div id="tab-measurements" class="tab-content hidden">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-3">Active Measurements</h3>
                    <div id="measurements-list" class="space-y-2 text-xs">
                        <div class="text-gray-600 text-center py-8">
                            <p>No measurements yet</p>
                            <p class="text-[10px] mt-1">Use üìè tool to measure distances</p>
                        </div>
                    </div>
                    <button id="clear-measurements" class="w-full mt-4 tool-btn py-2 rounded text-xs">Clear All Measurements</button>
                </div>

                <!-- Report Tab -->
                <div id="tab-report" class="tab-content hidden">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-3">Structured Report</h3>
                    <div id="report-content" class="text-xs space-y-3 mono">
                        <div class="text-gray-600 text-center py-8">
                            <p>No report generated</p>
                            <p class="text-[10px] mt-1">Complete analysis to generate report</p>
                        </div>
                    </div>
                    <button id="copy-report" class="w-full mt-4 tool-btn py-2 rounded text-xs hidden">üìã Copy to Clipboard</button>
                </div>

                <!-- 3D View Tab -->
                <div id="tab-3d" class="tab-content hidden">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wide mb-3">3D Reconstruction</h3>
                    <div id="3d-placeholder" class="text-center py-8 text-gray-600">
                        <svg class="mx-auto h-12 w-12 mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
                        </svg>
                        <p class="text-sm">No 3D reconstruction yet</p>
                        <p class="text-xs mt-1">Upload image and generate 3D view</p>
                    </div>
                    <div id="3d-container" class="hidden">
                        <div id="3d-canvas-container" class="bg-black rounded border border-[#2d2d2d] mb-3" style="height: 320px; position: relative;">
                            <canvas id="three-canvas"></canvas>
                            <div id="3d-loading" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 hidden">
                                <div class="loader mb-2"></div>
                                <p class="text-xs text-gray-400">Generating 3D reconstruction...</p>
                                <p class="text-[10px] text-gray-500 mt-1">AI synthesizing CT slices</p>
                            </div>
                        </div>
                        <div class="space-y-2">
                            <button id="generate-3d-btn" class="w-full bg-[#0ea5e9] hover:bg-[#0284c7] text-white py-2 rounded text-xs font-medium transition-colors">
                                Generate 3D Reconstruction
                            </button>
                            <div id="3d-controls" class="hidden space-y-2">
                                <div class="flex items-center justify-between text-xs">
                                    <span class="text-gray-400">Rotation Speed</span>
                                    <input id="rotation-speed" type="range" min="0" max="20" value="5" class="w-32">
                                </div>
                                <div class="flex items-center justify-between text-xs">
                                    <span class="text-gray-400">Opacity</span>
                                    <input id="opacity-slider" type="range" min="10" max="100" value="80" class="w-32">
                                </div>
                                <div class="flex gap-2">
                                    <button id="reset-camera-btn" class="flex-1 tool-btn py-1 rounded text-xs">Reset View</button>
                                    <button id="toggle-rotation-btn" class="flex-1 tool-btn py-1 rounded text-xs">Pause</button>
                                </div>
                            </div>
                        </div>
                        <div class="mt-3 p-2 bg-yellow-900/20 border border-yellow-800/50 rounded text-[10px] text-yellow-300">
                            ‚ö†Ô∏è This 3D reconstruction is AI-generated from a single 2D slice and is for visualization purposes only. Not for diagnostic use.
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar h-7 px-4 flex items-center space-x-6 mono">
        <span id="status-text">Ready</span>
        <span class="text-gray-700">|</span>
        <span id="status-confidence">Confidence: -</span>
        <span class="text-gray-700">|</span>
        <span id="status-time">Processing: -</span>
        <span class="text-gray-700">|</span>
        <span id="status-image">No image loaded</span>
        <div class="ml-auto text-[10px] text-gray-700">CEREBRO v1.0 | Tsinghua IEDE 2025</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
    // ============ STATE MANAGEMENT ============
    const state = {
        currentTool: 'pan',
        uploadedFile: null,
        imageLoaded: false,
        analysisData: null,
        measurements: [],
        tempMeasurement: null,
        scale: 1,
        panX: 0,
        panY: 0,
        isPanning: false,
        lastMouseX: 0,
        lastMouseY: 0,
        pixelSpacing: 0.5, // mm per pixel (approximate for CT)
    };

    // ============ DOM ELEMENTS ============
    const canvas = document.getElementById('image-canvas');
    const ctx = canvas.getContext('2d');
    const viewerContainer = document.getElementById('viewer-container');
    const uploadPlaceholder = document.getElementById('upload-placeholder');
    const fileInput = document.getElementById('file-input');
    const heatmapOverlay = document.getElementById('heatmap-overlay');

    // Tools
    const toolUpload = document.getElementById('tool-upload');
    const toolPan = document.getElementById('tool-pan');
    const toolZoom = document.getElementById('tool-zoom');
    const toolMeasure = document.getElementById('tool-measure');
    const toolAnnotate = document.getElementById('tool-annotate');
    const toolClear = document.getElementById('tool-clear');

    // Patient inputs
    const inputName = document.getElementById('input-name');
    const inputAge = document.getElementById('input-age');
    const inputSex = document.getElementById('input-sex');
    const inputId = document.getElementById('input-id');
    const inputSymptoms = document.getElementById('input-symptoms');

    // Tabs
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    // Analysis
    const analyzeBtn = document.getElementById('analyze-btn');
    const analyzeText = document.getElementById('analyze-text');
    const analyzeLoader = document.getElementById('analyze-loader');
    const analysisPlaceholder = document.getElementById('analysis-placeholder');
    const analysisResult = document.getElementById('analysis-result');
    const analysisError = document.getElementById('analysis-error');

    // Header buttons
    const saveBtn = document.getElementById('save-btn');
    const exportBtn = document.getElementById('export-btn');
    const resetHeaderBtn = document.getElementById('reset-header-btn');

    // Measurements
    const measurementsList = document.getElementById('measurements-list');
    const clearMeasurementsBtn = document.getElementById('clear-measurements');

    // 3D View elements
    const generate3DBtn = document.getElementById('generate-3d-btn');
    const threeDContainer = document.getElementById('3d-container');
    const threeDPlaceholder = document.getElementById('3d-placeholder');
    const threeDLoading = document.getElementById('3d-loading');
    const threeDControls = document.getElementById('3d-controls');
    const rotationSpeedSlider = document.getElementById('rotation-speed');
    const opacitySlider = document.getElementById('opacity-slider');
    const resetCameraBtn = document.getElementById('reset-camera-btn');
    const toggleRotationBtn = document.getElementById('toggle-rotation-btn');

    // Status bar
    const statusText = document.getElementById('status-text');
    const statusConfidence = document.getElementById('status-confidence');
    const statusTime = document.getElementById('status-time');
    const statusImage = document.getElementById('status-image');

    // ============ UTILITY FUNCTIONS ============
    function generatePatientId() {
        const now = new Date();
        return `AUTO-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${String(Math.floor(Math.random()*9999)).padStart(4,'0')}`;
    }

    function updateMetadata() {
        const name = inputName.value || 'Anonymous';
        const age = inputAge.value || '-';
        const sex = inputSex.value || '-';
        const id = inputId.value || '-';
        
        document.getElementById('patient-name').textContent = name;
        document.getElementById('patient-age').textContent = age;
        document.getElementById('patient-sex').textContent = sex;
        document.getElementById('patient-id').textContent = id;
        
        document.getElementById('meta-patient-overlay').textContent = `${name} | ${age}y ${sex}`;
        
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        document.getElementById('study-date').textContent = `${dateStr} ${timeStr}`;
        document.getElementById('meta-date-overlay').textContent = dateStr;
    }

    // ============ TOOL MANAGEMENT ============
    function setTool(tool) {
        state.currentTool = tool;
        document.querySelectorAll('[id^="tool-"]').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`tool-${tool}`).classList.add('active');
        
        canvas.style.cursor = tool === 'pan' ? 'grab' : tool === 'measure' ? 'crosshair' : 'default';
        statusText.textContent = `Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`;
    }

    toolUpload.addEventListener('click', () => fileInput.click());
    toolPan.addEventListener('click', () => setTool('pan'));
    toolZoom.addEventListener('click', () => setTool('zoom'));
    toolMeasure.addEventListener('click', () => setTool('measure'));
    toolAnnotate.addEventListener('click', () => setTool('annotate'));
    toolClear.addEventListener('click', clearMeasurements);

    // ============ TAB MANAGEMENT ============
    tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const tab = btn.dataset.tab;
            tabButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            tabContents.forEach(content => content.classList.add('hidden'));
            document.getElementById(`tab-${tab}`).classList.remove('hidden');
        });
    });

    // ============ IMAGE LOADING ============
    let loadedImage = null;

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            loadImage(file);
        }
    });

    viewerContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        viewerContainer.style.borderColor = '#0ea5e9';
    });

    viewerContainer.addEventListener('dragleave', () => {
        viewerContainer.style.borderColor = '#2d2d2d';
    });

    viewerContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        viewerContainer.style.borderColor = '#2d2d2d';
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
            loadImage(file);
        }
    });

    function loadImage(file) {
        state.uploadedFile = file;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                loadedImage = img;
                state.imageLoaded = true;
                
                // Set canvas size to image size
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Center and fit image
                fitImageToViewer();
                
                uploadPlaceholder.classList.add('hidden');
                canvas.classList.remove('hidden');
                
                renderCanvas();
                
                statusImage.textContent = `Image: ${img.width}√ó${img.height}px`;
                statusText.textContent = 'Ready - Image loaded';
                
                if (!inputId.value) {
                    inputId.value = generatePatientId();
                }
                updateMetadata();
                
                // Show 3D UI
                threeDPlaceholder.classList.add('hidden');
                threeDContainer.classList.remove('hidden');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function fitImageToViewer() {
        const containerWidth = viewerContainer.clientWidth;
        const containerHeight = viewerContainer.clientHeight;
        const imgAspect = loadedImage.width / loadedImage.height;
        const containerAspect = containerWidth / containerHeight;
        
        if (imgAspect > containerAspect) {
            state.scale = (containerWidth * 0.9) / loadedImage.width;
        } else {
            state.scale = (containerHeight * 0.9) / loadedImage.height;
        }
        
        state.panX = 0;
        state.panY = 0;
        updateZoomDisplay();
    }

    function updateZoomDisplay() {
        const zoomPercent = Math.round(state.scale * 100);
        document.getElementById('meta-zoom').textContent = `Zoom: ${zoomPercent}%`;
    }

    // ============ CANVAS RENDERING ============
    function renderCanvas() {
        if (!loadedImage) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(loadedImage, 0, 0);
        
        // Draw measurements
        state.measurements.forEach((m, idx) => {
            drawMeasurement(m, idx);
        });
        
        // Draw temp measurement
        if (state.tempMeasurement) {
            drawMeasurement(state.tempMeasurement, -1, true);
        }
    }

    function drawMeasurement(m, idx, isTemp = false) {
        const { x1, y1, x2, y2 } = m;
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = isTemp ? '#60a5fa' : '#0ea5e9';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw points
        [{ x: x1, y: y1 }, { x: x2, y: y2 }].forEach(pt => {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = isTemp ? '#60a5fa' : '#0ea5e9';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
        
        // Calculate distance
        const dx = x2 - x1;
        const dy = y2 - y1;
        const pixelDistance = Math.sqrt(dx * dx + dy * dy);
        const mmDistance = pixelDistance * state.pixelSpacing;
        
        // Draw label
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        const label = `${mmDistance.toFixed(1)} mm`;
        
        ctx.font = '12px IBM Plex Mono';
        ctx.fillStyle = '#0ea5e9';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        
        // Background for text
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(midX - textWidth / 2 - 4, midY - 18, textWidth + 8, 16);
        
        ctx.fillStyle = '#0ea5e9';
        ctx.fillText(label, midX, midY - 4);
    }

    // ============ MOUSE INTERACTION ============
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('wheel', handleWheel);

    function getCanvasCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function handleMouseDown(e) {
        const coords = getCanvasCoordinates(e);
        
        if (state.currentTool === 'pan') {
            state.isPanning = true;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        } else if (state.currentTool === 'measure') {
            if (!state.tempMeasurement) {
                state.tempMeasurement = {
                    x1: coords.x,
                    y1: coords.y,
                    x2: coords.x,
                    y2: coords.y
                };
            }
        }
    }

    function handleMouseMove(e) {
        if (state.currentTool === 'pan' && state.isPanning) {
            const dx = e.clientX - state.lastMouseX;
            const dy = e.clientY - state.lastMouseY;
            state.panX += dx;
            state.panY += dy;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
            updateCanvasTransform();
        } else if (state.currentTool === 'measure' && state.tempMeasurement) {
            const coords = getCanvasCoordinates(e);
            state.tempMeasurement.x2 = coords.x;
            state.tempMeasurement.y2 = coords.y;
            renderCanvas();
        }
    }

    function handleMouseUp(e) {
        if (state.currentTool === 'pan') {
            state.isPanning = false;
            canvas.style.cursor = 'grab';
        } else if (state.currentTool === 'measure' && state.tempMeasurement) {
            const dx = state.tempMeasurement.x2 - state.tempMeasurement.x1;
            const dy = state.tempMeasurement.y2 - state.tempMeasurement.y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                state.measurements.push({ ...state.tempMeasurement });
                updateMeasurementsList();
            }
            state.tempMeasurement = null;
            renderCanvas();
        }
    }

    function handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        state.scale *= delta;
        state.scale = Math.max(0.1, Math.min(5, state.scale));
        updateCanvasTransform();
        updateZoomDisplay();
    }

    function updateCanvasTransform() {
        canvas.style.transform = `translate(-50%, -50%) translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
    }

    // ============ MEASUREMENTS UI ============
    function updateMeasurementsList() {
        if (state.measurements.length === 0) {
            measurementsList.innerHTML = `
                <div class="text-gray-600 text-center py-8">
                    <p>No measurements yet</p>
                    <p class="text-[10px] mt-1">Use üìè tool to measure distances</p>
                </div>
            `;
            return;
        }
        
        measurementsList.innerHTML = state.measurements.map((m, idx) => {
            const dx = m.x2 - m.x1;
            const dy = m.y2 - m.y1;
            const pixelDistance = Math.sqrt(dx * dx + dy * dy);
            const mmDistance = (pixelDistance * state.pixelSpacing).toFixed(1);
            
            return `
                <div class="flex items-center justify-between p-2 bg-[#2d2d2d] rounded">
                    <div class="flex items-center space-x-2">
                        <span class="text-[#0ea5e9]">üìè</span>
                        <span class="mono">Measurement ${idx + 1}</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="mono font-semibold text-[#0ea5e9]">${mmDistance} mm</span>
                        <button class="text-red-400 hover:text-red-300" onclick="deleteMeasurement(${idx})">‚úï</button>
                    </div>
                </div>
            `;
        }).join('');
    }

    window.deleteMeasurement = function(idx) {
        state.measurements.splice(idx, 1);
        updateMeasurementsList();
        renderCanvas();
    };

    function clearMeasurements() {
        state.measurements = [];
        state.tempMeasurement = null;
        updateMeasurementsList();
        renderCanvas();
    }

    clearMeasurementsBtn.addEventListener('click', clearMeasurements);

    // ============ AI ANALYSIS ============
    analyzeBtn.addEventListener('click', async () => {
        if (!state.imageLoaded) {
            showError('Please upload a CT scan image first');
            return;
        }
        
        const symptoms = inputSymptoms.value.trim();
        if (!symptoms) {
            showError('Please enter patient symptoms and history');
            return;
        }
        
        setAnalysisState('loading');
        
        try {
            const base64Image = canvas.toDataURL('image/jpeg').split(',')[1];
            const startTime = Date.now();
            const result = await getAIAnalysis(base64Image, symptoms);
            const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
            
            state.analysisData = result;
            displayAnalysisResults(result);
            statusTime.textContent = `Processing: ${processingTime}s`;
            
            // Switch to analysis tab
            document.querySelector('[data-tab="analysis"]').click();
        } catch (error) {
            console.error('Analysis failed:', error);
            showError(`Analysis failed: ${error.message}`);
        }
    });

    function setAnalysisState(state) {
        if (state === 'loading') {
            analyzeText.classList.add('hidden');
            analyzeLoader.classList.remove('hidden');
            analyzeBtn.disabled = true;
            statusText.textContent = 'Running AI analysis...';
        } else {
            analyzeText.classList.remove('hidden');
            analyzeLoader.classList.add('hidden');
            analyzeBtn.disabled = false;
            statusText.textContent = 'Ready';
        }
    }

    function showError(message) {
        analysisError.textContent = message;
        analysisError.classList.remove('hidden');
        analysisPlaceholder.classList.add('hidden');
        analysisResult.classList.add('hidden');
        setAnalysisState('idle');
        
        setTimeout(() => {
            analysisError.classList.add('hidden');
            analysisPlaceholder.classList.remove('hidden');
        }, 5000);
    }

    async function getAIAnalysis(base64Image, symptoms) {
        const apiKey = "AIzaSyAFNjONYeiQ6HkY4RKdyeJLFpfIbAdBxJk";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;

        const systemPrompt = `You are CEREBRO, an expert radiology AI for stroke triage in clinical settings.

Analyze the brain CT scan and patient history to provide a professional triage assessment.

Respond with a single JSON object:
{
  "triage_level": "Critical" | "High" | "Moderate" | "Low",
  "diagnosis": "Brief diagnosis (e.g., 'Hemorrhagic Stroke Suspected')",
  "confidence": number (0-100),
  "summary": "Professional clinical summary with specific CT findings, mechanisms, and clinical correlation. Mention visible abnormalities, their location, and significance.",
  "localization": { "x": number, "y": number, "radius": number } | null,
  "recommendations": ["recommendation1", "recommendation2", "recommendation3"]
}

For localization: x, y are percentages (0-100) from top-left, radius is percentage of shortest side. Only include if clear focal abnormality is visible and triage is High/Critical.

Recommendations should be specific clinical actions (e.g., "Immediate neurosurgery consult", "CT angiography within 15 minutes").`;

        const payload = {
            systemInstruction: { parts: [{ text: systemPrompt }] },
            contents: [{
                parts: [
                    { text: `Patient History:\n${symptoms}` },
                    { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                ]
            }],
            generationConfig: { responseMimeType: "application/json" }
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('API request failed');
        
        const result = await response.json();
        
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            return JSON.parse(result.candidates[0].content.parts[0].text);
        }
        
        throw new Error('Invalid API response');
    }

    function displayAnalysisResults(data) {
        const { triage_level, diagnosis, confidence, summary, localization, recommendations } = data;
        
        // Show result container
        analysisPlaceholder.classList.add('hidden');
        analysisError.classList.add('hidden');
        analysisResult.classList.remove('hidden');
        
        // Urgency banner
        const urgencyStyles = {
            'Critical': { class: 'urgency-critical', icon: 'üö®' },
            'High': { class: 'urgency-high', icon: '‚ö†Ô∏è' },
            'Moderate': { class: 'urgency-moderate', icon: '‚ö°' },
            'Low': { class: 'urgency-low', icon: '‚úì' }
        };
        
        const style = urgencyStyles[triage_level] || urgencyStyles['Moderate'];
        const banner = document.getElementById('urgency-banner');
        banner.className = `p-3 rounded border flex items-center space-x-3 ${style.class}`;
        document.getElementById('urgency-icon').textContent = style.icon;
        document.getElementById('urgency-diagnosis').textContent = diagnosis;
        document.getElementById('urgency-level').textContent = `Priority: ${triage_level.toUpperCase()}`;
        
        // Confidence
        document.getElementById('confidence-value').textContent = `${confidence}%`;
        document.getElementById('confidence-bar').style.width = `${confidence}%`;
        statusConfidence.textContent = `Confidence: ${confidence}%`;
        
        // Summary
        document.getElementById('ai-summary').textContent = summary;
        
        // Recommendations
        const recList = document.getElementById('recommendations-list');
        if (recommendations && recommendations.length > 0) {
            recList.innerHTML = recommendations.map(r => `<li>‚Ä¢ ${r}</li>`).join('');
        }
        
        // Heatmap
        if (localization && (triage_level === 'High' || triage_level === 'Critical')) {
            showHeatmap(localization);
        } else {
            heatmapOverlay.classList.add('hidden');
        }
        
        // Generate report
        generateReport(data);
        
        setAnalysisState('idle');
    }

    function showHeatmap(loc) {
        const rect = canvas.getBoundingClientRect();
        const x = rect.left + (loc.x / 100) * rect.width;
        const y = rect.top + (loc.y / 100) * rect.height;
        const size = (loc.radius / 100) * Math.min(rect.width, rect.height) * 2;
        
        heatmapOverlay.style.left = `${x - size / 2}px`;
        heatmapOverlay.style.top = `${y - size / 2}px`;
        heatmapOverlay.style.width = `${size}px`;
        heatmapOverlay.style.height = `${size}px`;
        heatmapOverlay.classList.remove('hidden');
    }

    function generateReport(data) {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        
        const report = `
CEREBRO AI STROKE TRIAGE REPORT
Generated: ${dateStr} at ${timeStr}

PATIENT INFORMATION
Name: ${inputName.value || 'Anonymous'}
ID: ${inputId.value || '-'}
Age: ${inputAge.value || '-'} years
Sex: ${inputSex.value || '-'}

CLINICAL HISTORY
${inputSymptoms.value}

AI ANALYSIS RESULTS
Triage Level: ${data.triage_level.toUpperCase()}
Diagnosis: ${data.diagnosis}
Confidence: ${data.confidence}%

FINDINGS
${data.summary}

RECOMMENDATIONS
${data.recommendations ? data.recommendations.map((r, i) => `${i + 1}. ${r}`).join('\n') : 'None'}

MEASUREMENTS
${state.measurements.length > 0 ? state.measurements.map((m, i) => {
    const dx = m.x2 - m.x1;
    const dy = m.y2 - m.y1;
    const dist = (Math.sqrt(dx * dx + dy * dy) * state.pixelSpacing).toFixed(1);
    return `${i + 1}. Linear measurement: ${dist} mm`;
}).join('\n') : 'No measurements recorded'}

---
This report was generated by CEREBRO AI Triage System
Tsinghua University IEDE Program - Group 28
This is an AI-assisted analysis and should be verified by a qualified radiologist.
        `.trim();
        
        document.getElementById('report-content').textContent = report;
        document.getElementById('copy-report').classList.remove('hidden');
    }

    // ============ REPORT ACTIONS ============
    document.getElementById('copy-report').addEventListener('click', () => {
        const report = document.getElementById('report-content').textContent;
        navigator.clipboard.writeText(report).then(() => {
            statusText.textContent = 'Report copied to clipboard';
            setTimeout(() => statusText.textContent = 'Ready', 2000);
        });
    });

    exportBtn.addEventListener('click', () => {
        if (!state.analysisData) {
            alert('Please run analysis first');
            return;
        }
        
        const report = document.getElementById('report-content').textContent;
        const blob = new Blob([report], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `CEREBRO_Report_${inputId.value || 'case'}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        
        statusText.textContent = 'Report exported';
        setTimeout(() => statusText.textContent = 'Ready', 2000);
    });

    saveBtn.addEventListener('click', () => {
        const caseData = {
            patient: {
                name: inputName.value,
                id: inputId.value,
                age: inputAge.value,
                sex: inputSex.value,
                symptoms: inputSymptoms.value
            },
            analysis: state.analysisData,
            measurements: state.measurements,
            timestamp: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(caseData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `CEREBRO_Case_${inputId.value || 'data'}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        statusText.textContent = 'Case saved';
        setTimeout(() => statusText.textContent = 'Ready', 2000);
    });

    resetHeaderBtn.addEventListener('click', resetApplication);

    function resetApplication() {
        if (state.analysisData && !confirm('Reset will clear all data. Continue?')) {
            return;
        }
        
        // Reset state
        state.uploadedFile = null;
        state.imageLoaded = false;
        state.analysisData = null;
        state.measurements = [];
        state.tempMeasurement = null;
        state.scale = 1;
        state.panX = 0;
        state.panY = 0;
        
        // Reset 3D
        syntheticSlices = [];
        if (brainMesh) {
            scene.remove(brainMesh);
            brainMesh = null;
        }
        
        // Reset UI
        canvas.classList.add('hidden');
        uploadPlaceholder.classList.remove('hidden');
        heatmapOverlay.classList.add('hidden');
        
        analysisPlaceholder.classList.remove('hidden');
        analysisResult.classList.add('hidden');
        analysisError.classList.add('hidden');
        
        threeDPlaceholder.classList.remove('hidden');
        threeDContainer.classList.add('hidden');
        threeDControls.classList.add('hidden');
        
        inputName.value = '';
        inputAge.value = '';
        inputSex.value = '';
        inputId.value = '';
        inputSymptoms.value = '';
        
        updateMeasurementsList();
        updateMetadata();
        
        statusText.textContent = 'Ready';
        statusConfidence.textContent = 'Confidence: -';
        statusTime.textContent = 'Processing: -';
        statusImage.textContent = 'No image loaded';
        
        document.querySelector('[data-tab="patient"]').click();
    }

    // ============ INITIALIZATION ============
    setTool('pan');
    updateMetadata();
    updateMeasurementsList();
    inputId.value = generatePatientId();

    // ============ 3D RECONSTRUCTION ============
    let scene, camera, renderer, brainMesh;
    let isRotating = true;
    let rotationSpeed = 0.005;
    let syntheticSlices = [];

    function init3DViewer() {
        const container = document.getElementById('3d-canvas-container');
        const canvas = document.getElementById('three-canvas');
        
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Camera
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 200);
        camera.lookAt(0, 0, 0);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(1, 1, 1);
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0x4488ff, 0.4);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);
        
        // Controls
        canvas.addEventListener('mousedown', on3DMouseDown);
        canvas.addEventListener('mousemove', on3DMouseMove);
        canvas.addEventListener('mouseup', on3DMouseUp);
        canvas.addEventListener('wheel', on3DWheel);
        
        animate3D();
    }

    let isDragging3D = false;
    let previousMousePosition = { x: 0, y: 0 };

    function on3DMouseDown(e) {
        isDragging3D = true;
        isRotating = false;
        toggleRotationBtn.textContent = 'Resume';
    }

    function on3DMouseMove(e) {
        if (isDragging3D && brainMesh) {
            const deltaX = e.offsetX - previousMousePosition.x;
            const deltaY = e.offsetY - previousMousePosition.y;
            
            brainMesh.rotation.y += deltaX * 0.01;
            brainMesh.rotation.x += deltaY * 0.01;
        }
        previousMousePosition = { x: e.offsetX, y: e.offsetY };
    }

    function on3DMouseUp(e) {
        isDragging3D = false;
    }

    function on3DWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 1.1 : 0.9;
        camera.position.z *= delta;
        camera.position.z = Math.max(50, Math.min(400, camera.position.z));
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        
        if (brainMesh && isRotating) {
            brainMesh.rotation.y += rotationSpeed;
        }
        
        renderer.render(scene, camera);
    }

    async function generate3DReconstruction() {
        if (!state.imageLoaded) {
            alert('Please upload a CT scan first');
            return;
        }

        threeDPlaceholder.classList.add('hidden');
        threeDContainer.classList.remove('hidden');
        threeDLoading.classList.remove('hidden');
        generate3DBtn.disabled = true;

        try {
            // Generate synthetic slices using AI
            const base64Image = canvas.toDataURL('image/jpeg').split(',')[1];
            await generateSyntheticSlices(base64Image);
            
            // Create 3D volume from slices
            create3DVolumeVisualization();
            
            threeDControls.classList.remove('hidden');
            statusText.textContent = '3D reconstruction complete';
        } catch (error) {
            console.error('3D generation failed:', error);
            alert('Failed to generate 3D reconstruction: ' + error.message);
            threeDPlaceholder.classList.remove('hidden');
            threeDContainer.classList.add('hidden');
        } finally {
            threeDLoading.classList.add('hidden');
            generate3DBtn.disabled = false;
        }
    }

    async function generateSyntheticSlices(base64Image) {
        const apiKey = "AIzaSyAFNjONYeiQ6HkY4RKdyeJLFpfIbAdBxJk";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;

        const prompt = `You are a medical imaging AI. Analyze this brain CT scan slice and provide parameters to simulate adjacent CT slices for 3D reconstruction.

Based on the visible anatomy, estimate:
1. Brain contour shape and size
2. Ventricular system visibility and size
3. Presence and location of any abnormalities (hemorrhage, infarct, mass effect)
4. Skull thickness and shape
5. Gray/white matter differentiation

Respond with JSON containing parameters for generating 7 synthetic slices (3 superior, current, 3 inferior):
{
  "slices": [
    {
      "position": -3,
      "brain_scale": number (0.6-1.0, smaller for superior slices),
      "ventricle_size": number (0.0-1.0, larger at mid-brain),
      "abnormality_visible": boolean,
      "abnormality_intensity": number (0.0-1.0),
      "overall_brightness": number (0.7-1.0)
    },
    ... 7 total entries from position -3 to +3
  ],
  "abnormality_location": {"x": number, "y": number, "z": number} | null,
  "brain_symmetry": number (0.0-1.0)
}

The current slice is position 0. Negative positions are superior (toward vertex), positive are inferior (toward base).`;

        const payload = {
            contents: [{
                parts: [
                    { text: prompt },
                    { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                ]
            }],
            generationConfig: { 
                responseMimeType: "application/json",
                temperature: 0.4
            }
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('AI slice generation failed');
        
        const result = await response.json();
        
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const sliceParams = JSON.parse(result.candidates[0].content.parts[0].text);
            
            // Generate actual image data for each synthetic slice
            syntheticSlices = await createSyntheticSliceImages(sliceParams);
            return sliceParams;
        }
        
        throw new Error('Invalid AI response for slice generation');
    }

    async function createSyntheticSliceImages(params) {
        const slices = [];
        const baseImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        for (let i = 0; i < params.slices.length; i++) {
            const sliceParam = params.slices[i];
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            const newCtx = newCanvas.getContext('2d');
            
            // Copy and modify base image
            const newImageData = newCtx.createImageData(canvas.width, canvas.height);
            
            for (let j = 0; j < baseImageData.data.length; j += 4) {
                const pixelIndex = j / 4;
                const x = pixelIndex % canvas.width;
                const y = Math.floor(pixelIndex / canvas.width);
                
                // Calculate distance from center
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dx = (x - centerX) / centerX;
                const dy = (y - centerY) / centerY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                
                // Apply transformations based on slice parameters
                const scaleFactor = sliceParam.brain_scale;
                const inBrain = distFromCenter < scaleFactor;
                
                let r = baseImageData.data[j];
                let g = baseImageData.data[j + 1];
                let b = baseImageData.data[j + 2];
                
                if (inBrain) {
                    // Adjust brightness
                    const brightness = sliceParam.overall_brightness;
                    r *= brightness;
                    g *= brightness;
                    b *= brightness;
                    
                    // Add some noise for realism
                    const noise = (Math.random() - 0.5) * 10;
                    r += noise;
                    g += noise;
                    b += noise;
                } else {
                    // Outside brain - darken significantly
                    r *= 0.3;
                    g *= 0.3;
                    b *= 0.3;
                }
                
                newImageData.data[j] = Math.max(0, Math.min(255, r));
                newImageData.data[j + 1] = Math.max(0, Math.min(255, g));
                newImageData.data[j + 2] = Math.max(0, Math.min(255, b));
                newImageData.data[j + 3] = 255;
            }
            
            newCtx.putImageData(newImageData, 0, 0);
            slices.push({
                position: sliceParam.position,
                canvas: newCanvas,
                params: sliceParam
            });
        }
        
        return slices;
    }

    function create3DVolumeVisualization() {
        // Clear existing mesh
        if (brainMesh) {
            scene.remove(brainMesh);
        }
        
        // Create group for all slice planes
        const volumeGroup = new THREE.Group();
        
        const sliceSpacing = 8; // Distance between slices
        
        syntheticSlices.forEach((slice, index) => {
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(slice.canvas);
            texture.needsUpdate = true;
            
            // Create plane geometry
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(geometry, material);
            plane.position.z = slice.position * sliceSpacing;
            
            volumeGroup.add(plane);
        });
        
        // Add wireframe box around volume
        const boxGeometry = new THREE.BoxGeometry(100, 100, sliceSpacing * 6);
        const boxEdges = new THREE.EdgesGeometry(boxGeometry);
        const boxLine = new THREE.LineSegments(
            boxEdges,
            new THREE.LineBasicMaterial({ color: 0x0ea5e9, opacity: 0.3, transparent: true })
        );
        volumeGroup.add(boxLine);
        
        scene.add(volumeGroup);
        brainMesh = volumeGroup;
        
        // Add abnormality marker if present
        if (state.analysisData?.localization) {
            const loc = state.analysisData.localization;
            const markerGeometry = new THREE.SphereGeometry(5, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            
            // Convert 2D location to 3D
            marker.position.set(
                (loc.x - 50) * 2,
                (50 - loc.y) * 2,
                0
            );
            
            volumeGroup.add(marker);
        }
    }

    // 3D Controls
    generate3DBtn.addEventListener('click', async () => {
        if (syntheticSlices.length === 0) {
            if (!scene) init3DViewer();
            await generate3DReconstruction();
        }
    });

    rotationSpeedSlider.addEventListener('input', (e) => {
        rotationSpeed = e.target.value / 1000;
    });

    opacitySlider.addEventListener('input', (e) => {
        if (brainMesh) {
            const opacity = e.target.value / 100;
            brainMesh.children.forEach(child => {
                if (child.material && child.material.opacity !== undefined) {
                    child.material.opacity = opacity;
                }
            });
        }
    });

    resetCameraBtn.addEventListener('click', () => {
        if (camera && brainMesh) {
            camera.position.set(0, 0, 200);
            camera.lookAt(0, 0, 0);
            brainMesh.rotation.set(0, 0, 0);
        }
    });

    toggleRotationBtn.addEventListener('click', () => {
        isRotating = !isRotating;
        toggleRotationBtn.textContent = isRotating ? 'Pause' : 'Resume';
    });

</script>

</body>
</html>